---
import Layout from "../../layouts/Layout.astro";
---

<Layout>
  <div>
    <h1>Dot Grid to Font</h1>
    <p>Convert a dot grid to a font</p>
    
    <div id="svg-container"></div>
    <div id="svg-container"></div>
  </div>
</Layout>
<script>
  // Tu función original INTACTA
  interface Config {
    pointRadius: number;
    spacing: number;
    backgroundColor: string;
    pointColor: string;
    padding: number;
    character: string;
    makeSelectable: boolean;
    forFont?: boolean;
    unitsPerEm?: number;
    advanceWidth?: number;
  }

  function matrixToSVG(
    matrix: number[][],
    config: Config = {
      pointRadius: 5,
      spacing: 25,
      backgroundColor: "#f8f9fa",
      pointColor: "#007bff",
      padding: 10,
      character: "",
      makeSelectable: true,
      forFont: false,
      unitsPerEm: 1000,
      advanceWidth: 600,
    }
  ) {
    if (!matrix || !Array.isArray(matrix) || matrix.length === 0) {
      throw new Error("La matriz debe ser un array bidimensional válido");
    }

    const rows = matrix.length;
    const cols = matrix[0].length;

    // Verificar que todas las filas tengan la misma longitud
    if (!matrix.every((row) => Array.isArray(row) && row.length === cols)) {
      throw new Error(
        "Todas las filas de la matriz deben tener la misma longitud"
      );
    }

    // Calcular dimensiones del SVG
    const gridWidth = (cols - 1) * config.spacing + config.pointRadius * 2;
    const gridHeight = (rows - 1) * config.spacing + config.pointRadius * 2;
    const svgWidth = gridWidth + config.padding * 2;
    const svgHeight = gridHeight + config.padding * 2;

    // Crear elementos SVG
    let svgContent = [];

    // Fondo
    svgContent.push(
      `<rect width="${svgWidth}" height="${svgHeight}" fill="${config.backgroundColor}"/>`
    );

    // Si es seleccionable, añadir texto invisible que represente el carácter
    if (config.makeSelectable && config.character) {
      svgContent.push(`<text x="${svgWidth / 2}" y="${svgHeight / 2}" 
          font-size="1" 
          fill="transparent" 
          text-anchor="middle" 
          dominant-baseline="middle" 
          style="user-select: text; -webkit-user-select: text; -moz-user-select: text; -ms-user-select: text;"
          >${config.character}</text>`);
    }

    // Puntos basados en la matriz
    for (let row = 0; row < rows; row++) {
      for (let col = 0; col < cols; col++) {
        if (matrix[row][col] === 1) {
          // Calcular posición del punto
          const x = config.padding + config.pointRadius + col * config.spacing;
          const y = config.padding + config.pointRadius + row * config.spacing;

          svgContent.push(
            `<circle cx="${x}" cy="${y}" r="${config.pointRadius}" fill="${config.pointColor}"/>`
          );
        }
      }
    }

    // Construir el SVG completo
    const svg = `<svg width="${svgWidth}" height="${svgHeight}" xmlns="http://www.w3.org/2000/svg">
        ${svgContent.join("\n    ")}
      </svg>`;

    return svg;
  }

  // Nueva función ADICIONAL solo para fuentes (no reemplaza la original)
  interface FontConfig extends Config {
    forFont?: boolean;
    unitsPerEm?: number;
    advanceWidth?: number;
    ascent?: number;
    descent?: number;
  }

  function matrixToFontSVG(matrix: number[][], config: FontConfig): string {
    // Si no es para fuente, usar la función original
    if (!config.forFont) {
      return matrixToSVG(matrix, config);
    }

    // Configuración específica para fuentes
    const fontConfig = {
      unitsPerEm: config.unitsPerEm || 1000,
      advanceWidth: config.advanceWidth || 600,
      ...config,
    };

    if (!matrix || !Array.isArray(matrix) || matrix.length === 0) {
      throw new Error("La matriz debe ser un array bidimensional válido");
    }

    const rows = matrix.length;
    const cols = matrix[0].length;

    if (!matrix.every((row) => Array.isArray(row) && row.length === cols)) {
      throw new Error(
        "Todas las filas de la matriz deben tener la misma longitud"
      );
    }

    // Calcular dimensiones del grid original
    const gridWidth = (cols - 1) * config.spacing + config.pointRadius * 2;
    const gridHeight = (rows - 1) * config.spacing + config.pointRadius * 2;
    const totalWidth = gridWidth + config.padding * 2;
    const totalHeight = gridHeight + config.padding * 2;

    // Escalar al sistema de coordenadas de fuente
    const scaleX = fontConfig.advanceWidth / totalWidth;
    const scaleY = fontConfig.unitsPerEm / totalHeight;

    let svgContent = [];

    // Para fuentes: solo los puntos, sin fondo
    for (let row = 0; row < rows; row++) {
      for (let col = 0; col < cols; col++) {
        if (matrix[row][col] === 1) {
          // Posición original
          const origX =
            config.padding + config.pointRadius + col * config.spacing;
          const origY =
            config.padding + config.pointRadius + row * config.spacing;

          // Escalar y invertir Y para fuentes (origen abajo-izquierda)
          const x = origX * scaleX;
          const y = fontConfig.unitsPerEm - origY * scaleY;

          svgContent.push(
            `<circle cx="${x}" cy="${y}" r="${config.pointRadius * Math.min(scaleX, scaleY)}" fill="${config.pointColor}"/>`
          );
        }
      }
    }

    // SVG con viewBox para fuentes
    const svg = `<svg width="${fontConfig.advanceWidth}" height="${fontConfig.unitsPerEm}" viewBox="0 0 ${fontConfig.advanceWidth} ${fontConfig.unitsPerEm}" xmlns="http://www.w3.org/2000/svg">
    ${svgContent.join("\n    ")}
  </svg>`;

    return svg;
  }

  // Generador de definiciones de glifos para fuentes
  class FontGlyphGenerator {
    private glyphs: Map<string, string> = new Map();
    private config: FontConfig;

    constructor(baseConfig: Partial<FontConfig> = {}) {
      this.config = {
        pointRadius: 20,
        spacing: 80,
        pointColor: "#000000",
        padding: 40,
        character: "",
        ascent: 800,
        descent: 200,
        unitsPerEm: 1000,
        advanceWidth: 600,
        backgroundColor: "#ffffff",
        makeSelectable: false,
        ...baseConfig,
      };
    }

    addGlyph(character: string, matrix: number[][]): void {
      const svg = matrixToFontSVG(matrix, { ...this.config, character });
      this.glyphs.set(character, svg);
    }

    // Convertir SVG a path data (simplificado)
    private svgToPathData(svg: string): string {
      // Esta es una implementación básica
      // En producción, usarías una librería como svg-path-parser
      const circles = svg.match(/<circle[^>]+>/g) || [];
      let pathData = "";

      circles.forEach((circle) => {
        const cxMatch = circle.match(/cx="([^"]+)"/);
        const cyMatch = circle.match(/cy="([^"]+)"/);
        const rMatch = circle.match(/r="([^"]+)"/);

        if (cxMatch && cyMatch && rMatch) {
          const cx = parseFloat(cxMatch[1]);
          const cy = parseFloat(cyMatch[1]);
          const r = parseFloat(rMatch[1]);

          // Crear un círculo como path
          pathData += `M ${cx - r} ${cy} `;
          pathData += `A ${r} ${r} 0 0 1 ${cx + r} ${cy} `;
          pathData += `A ${r} ${r} 0 0 1 ${cx - r} ${cy} Z `;
        }
      });

      return pathData;
    }

    // Generar fuente TTF usando opentype.js (requiere instalación)
    generateTTFFont(): string {
      // Este código requiere la librería opentype.js
      return `
// Para usar con opentype.js:
import opentype from 'opentype.js';

const glyphs = [
  // Glifo para espacio
  new opentype.Glyph({
    name: 'space',
    unicode: 32,
    advanceWidth: ${this.config.advanceWidth}
  }),
  
  ${Array.from(this.glyphs.entries())
    .map(
      ([char, svg]) => `
  // Glifo para '${char}'
  new opentype.Glyph({
    name: '${char}',
    unicode: ${char.charCodeAt(0)},
    advanceWidth: ${this.config.advanceWidth},
    path: new opentype.Path.fromPathData('${this.svgToPathData(svg)}')
  })`
    )
    .join(",\n  ")}
];

const font = new opentype.Font({
  familyName: 'MatrixFont',
  styleName: 'Regular',
  unitsPerEm: ${this.config.unitsPerEm},
  ascender: ${this.config.ascent},
  descender: -${this.config.descent},
  glyphs: glyphs
});

// Exportar como buffer para descarga
const buffer = font.toArrayBuffer();
`;
    }

    // Generar fuente web usando FontForge Python script
    generateFontForgeScript(): string {
      return `#!/usr/bin/env python3
# Script para FontForge para generar fuente desde SVGs
import fontforge
import os

# Crear nueva fuente
font = fontforge.font()
font.fontname = "MatrixFont"
font.familyname = "Matrix Font"
font.fullname = "Matrix Font Regular"
font.weight = "Regular"
font.encoding = "unicode"

# Configurar métricas
font.em = ${this.config.unitsPerEm}
font.ascent = ${this.config.ascent}
font.descent = ${this.config.descent}

${Array.from(this.glyphs.entries())
  .map(
    ([char, svg]) => `
# Glifo para '${char}'
glyph = font.createChar(${char.charCodeAt(0)}, "${char}")
glyph.importOutlines("${char}.svg")  # Necesitas guardar el SVG como archivo
glyph.width = ${this.config.advanceWidth}
`
  )
  .join("\n")}

# Generar fuente
font.generate("MatrixFont.ttf")
font.generate("MatrixFont.woff")
font.generate("MatrixFont.woff2")
print("Fuentes generadas exitosamente")
`;
    }

    // Generar CSS para usar la fuente web
    generateWebFontCSS(fontName: string = "MatrixFont"): string {
      return `@font-face {
  font-family: '${fontName}';
  src: url('${fontName}.woff2') format('woff2'),
       url('${fontName}.woff') format('woff'),
       url('${fontName}.ttf') format('truetype');
  font-weight: normal;
  font-style: normal;
  font-display: swap;
}

.matrix-font {
  font-family: '${fontName}', monospace;
  font-feature-settings: "liga" off;
}

/* Ejemplo de uso */
.matrix-text {
  font-family: '${fontName}';
  font-size: 24px;
  line-height: 1.2;
}`;
    }

    // Obtener todos los SVGs generados
    getAllSVGs(): Map<string, string> {
      return new Map(this.glyphs);
    }
  }

  // Ejemplo de uso
  const fontGenerator = new FontGlyphGenerator({
    pointRadius: 5,
    spacing: 25,
    unitsPerEm: 1000,
    advanceWidth: 400,
    padding: 10,
  });

  // Matrices de ejemplo para diferentes caracteres
  const letterA = [
    [0, 0, 1, 0, 0],
    [0, 1, 0, 1, 0],
    [1, 0, 0, 0, 1],
    [1, 1, 1, 1, 1],
    [1, 0, 0, 0, 1],
    [1, 0, 0, 0, 1],
    [1, 0, 0, 0, 1],
  ];

  const letterB = [
    [1, 1, 1, 1, 0],
    [1, 0, 0, 0, 1],
    [1, 0, 0, 0, 1],
    [1, 1, 1, 1, 0],
    [1, 0, 0, 0, 1],
    [1, 0, 0, 0, 1],
    [1, 1, 1, 1, 0],
  ];

  // Demostración: Tu función original sigue funcionando igual
  console.log("=== Tu función original (sin cambios) ===");
  const svgOriginal = matrixToSVG(letterA, {
    pointRadius: 5,
    spacing: 25,
    backgroundColor: "#f8f9fa",
    pointColor: "#007bff",
    padding: 10,
    character: "A",
    makeSelectable: true,
  });
  console.log("SVG original para 'A':", svgOriginal);

  // Previsualización como antes
  console.log("\n=== Previsualización (igual que antes) ===");
  const preview = fontGenerator.addGlyph("A", letterA);
  console.log("Preview 'A':", preview);

  // Versión para fuente
  fontGenerator.addGlyph("A", letterA);
  fontGenerator.addGlyph("B", letterB);

  // Generar archivos
  console.log("=== CSS para fuente web ===");
  console.log(fontGenerator.generateWebFontCSS());

  console.log("\n=== Script de FontForge ===");
  console.log(fontGenerator.generateFontForgeScript());

  console.log("\n=== Código para opentype.js ===");
  console.log(fontGenerator.generateTTFFont());
</script>
